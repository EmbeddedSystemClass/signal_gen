\input texinfo    @c -*-texinfo-*-
%
% fine-delay.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding UTF-8
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent 3
@comment %**end of header

@setchapternewpage off

@set update-month December 2012

@finalout

@titlepage
@title Fine Delay Design Notes
@subtitle FMC Delay 1ns-4cha
@author CERN BE-CO-HT / Tomasz Włostowski

@end titlepage
@headings single

@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@chapter Introduction

This manual provides detailed information about the designs of the
Fine Delay mezzanine (further abbeviated as the FD) and the VHDL core supporting it. 
It is not intended for the FD's users and it is definitely not official/formal/certified. 
Its target are driver developers, carrier/hardware integrators,
people interested in building similar devices and looking for hints and inspiration
or the folks curious why something was done this and not the other way. I therefore
kindly ask the readers to be tolerant for the informal language used in this document.
The manual references to the schematics and the PCB design every couple of lines, so please print them before reading.

@chapter The Hardware

@section Overview

The FD is an FMC mezzanine card, which inputs a TTL pulse and reproduces it on one or more of 4 TTL
outputs after a given time, which can be programmed to any value between 500 ns and 12 seconds with 10 ps resolution. 
The exact specifications can be found in the official @cite{Fine Delay User's Manual}.

The FD's principle of operation is explained in @ref{fig:fd_simple}. In a nutshell, the card takes the input pulse,
time tags it, adds the desired delay to the time tag and produces a pulse on the output when the time base counter hits 
the adjusted tag value. The fine part (that is, less than a single clock cycle) is adjusted by an external programmable delay line.

@float Figure,fig:fd_simple
@center @image{drawings/simple_diagram, 15cm,,,.pdf}
@caption{Simplified principle of FD operation.}
@end float


@ref{fig:fd_block} depicts a more detailed hardware block diagram, comprising the following major design blocks:
@itemize
@item the TDC, using an Acam TDC-GPX chip,
@item output stages, based on EPT195 programmable delay chips,
@item clock distribution circuit, encompassing a multi-output PLL (AD9516),
@item power supplies, SPI general-purpose IO, sensors and ID EEPROM.
@end itemize

@float Figure,fig:fd_block
@center @image{drawings/block_diagram, 15cm,,,.pdf}
@caption{Block diagram of a FD card.}
@end float

@section Clock distribution

Relevant files: @code{clock_generator.SchDoc}

The FD utilizes a number of clock signals of different frequencies to synchronize the TDC,
the output stages and the FPGA core altogether. All clock signals are generated by the Analog Devices`
AD9516-4 integrated PLL/clock fanout (IC4). This particular chip was chosen due to its wide 
configuration capabilities (frequency settings, fine per-output phase adjustment), support 
for multiple I/O standards (PECL, single-ended, etc) and low inter-output skew. 
The PLL is programmed to produce:
@itemize
@item OUT9: 125 MHz FPGA reference clock (LVDS). The choice of 125 MHz reference is forced 
by compliance with White Rabbit and Gigabit Ethernet for providing external, 
sub-ns synchronization of multiple cards. All other clocks used in the design 
are derived from 125 MHz.
@item OUT0..3: 250 MHz clocks tht drive the output flip flops. We use twice the reference 
frequency, because the FPGA outputs operate in DDR mode. Outputs 0..2 are inverted to
simplify PCB routing (AD9516's programmable output polarity control ensures they are all in phase).
@item OUT7: 31.25 Mhz TDC reference clock (LVCMOS). Must be lower than the TDC maximum 
reference frequency (40 MHz) and an integer fraction of 125 MHz. 31.25 MHz is the largest
possible value. 
@item OUT4, OUT5: 7.125 MHz TDC start signals (LVPECL to the TDC, LVCMOS to the FPGA). 
Rising edges of these clocks are the reference points for time interval measurement in the TDC. 
7.125 MHz is the fastest frequency that is an integer fraction of 125 MHz and meets the maximum 
start pulse frequency constraint of the TDC (10 MHz).
@end itemize

AD9516's PLL bandwidth is set by the loop filter components (R41, C33 and neighbours) 
and is set to 10 kHz, resulting in optimal phase noise distribution. The PLL is referenced 
by a 25 MHz VCTCXO OSC5, a Mercury Crystal VM53S3-series oscillator. The TCXO can be digitally
tuned within (±10 ppm) range by the 16-bit  DAC IC14 (AD5662). Low-cost shunt regulator IC10 
(LM336) provides the reference voltage for the DAC (it needs not be extremely stable because the 
whole circuit usually works in a feedback loop, see fig. @ref{fig:wr_pll}). The combination 
of the used DAC and oscillator meets the requirements of Synchronous Ethernet and White Rabbit 
for synchronization: 1kHz PLL bandwidth and tuning sensitivity of < 1 ppb and range of > ±2.5 ppm. 
Careful readers should have noticed at this point that it's not possible to directly feed an 
external reference clock to the card. This limitation is caused by the lack of carrier to 
mezzanine clock signals in the low pin version of the FMC connector and is solved by locking 
the cards' clock to the the external frequency with a PLL implemented in the carrier FPGA. 

The PLL is powered from 3.3V filtered by an LC circuit (L3 and its surroundings), following the 
manufacturer's recommendation. Programming is performed via the SPI bus, directly connected 
to the FPGA. A multipurpose STATUS signal is also routed to the FPGA, mainly for fast 
out-of-lock detection.

@section Input stage

Relevant files: @code{input_stage.SchDoc}

The role of the input stage is to adapt the incoming trigger pulses so that they can be digested 
by the TDC and the FPGA. Following the signal path starting from the input connector:
@itemize
@item fuse F5 protects the input stage against a serious overvoltage/overcurrent 
(e.g. connecting the input to a 12 V DC power supply)
@item resistors R110, R116, R117 along with the mosfet T2 constitute a programmable 
50 Ohm termination. 3 resistors connected in parallel were used to give more freedom
for the PCB designer (the board is packed quite tightly). R76 ensures the calibration mode
is off by default. 
@item PIN diodes D6 (BAR66) and resistor R57 form a fast overvoltage clamping circuit. 
R57 reduces the D6's clamping current (~200 mA) for small overloads, clamping currents 
above 200 mA will anyway blow the fuse F5. R108 pulls down the input, lowering it's impedance 
and preventing an unconnected input from taking glitches as legitimate trigger pulses.
@item FET switch IC18 (TS3USB221) is selects the signal that drices the TDC input 
between the trigger input and a calibration line driven by the FPGA (the calibration process
will be discussed later). TRIG_SEL line selects the active input (by default, it's the trigger in).
@item Output of the switch feeds 3 other components: an LVTTL to LVPECL buffer (IC5, 100EPT29), 
which drives the TDC's Stop input, an LVCMOS buffer (IC23, LVC125) that feeds the trigger signal
to the FPGA and a single-gate D flip flop which takes part in the calibration process 
(please be patient...). The physical length of the signal path between these components 
is very short (5mm on the PCB) to avoid stubs and reflections.
@end itemize
 
@section The TDC

Relevant files: @code{acam_tdc.SchDoc}

The TDC, just as it's name says, converts an incoming pulse into a digital value, denoting the 
moment in time at which the pulse's rising (or falling) edge occured. Well, it's not entirely 
true. In a real world, a TDC needs a notion of time, so it's output is the time difference 
between two inputs, called Start and Stop. The start input is used to provide the time base 
(i.e. pulses with edges occuring at known moments in time) and the stop input(s) take in the 
pulses to be timestamped.

The FD's TDC is a single-chip solution, called TDC-GPX made by Acam (IC8). It can simultaneously 
timestamp from 1 to 8 inputs, with accuracy and repetition rate depending on the mode of 
operation (R, I, M, G-modes, more details in the @cite{TDC-GPX datasheet}). In the FD, the ACAM serves two purposes:
@itemize
@item The obvious one: @b{time tagging trigger pulses}. The TDC in configured in the R-mode, with a single
stop input, providing 10 Mpulses/second throughput, measurement range of 40 us and resolution (one-sigma) 
of 27 ps. In this mode, LVPECL inputs are used, the Start being connected to the 7.125 MHz PLL 
clock, and the Stop feeding in trigger pulses. As a result, we get the time difference between 
the rising edge of the most recent start pulse and the stop pulse - for a 7.125 MHz start signal 
frequency, it gives a measurement range of 0 to 128 ns. The coarse part of the timestamp is 
produced with a counter inside the FPGA and the two values are merged together to obtain the 
final, accurate value (see @ref{Timestamp processing}).

@item @b{Calibration} of the output delay lines, which is performed during initialization 
of the card. It's goal is to determine the setpoint for each delay line that produces a delay of exactly 8 ns 
(single reference clock cycle), and thus compensates for the PVT effects. The TDC is working in the I-mode 
(81 ps resolution), with one LVTTL start connected to an FPGA output generating arbitrary pulses and 
the 4 LVTTL stop inputs wired to the outputs of the delay chips. 
@end itemize

The interesting part about the TDC is how it measures time differences so accurately - obviously, 
it does not have a counter running at 1/82 ps (= ~12 GHz). Instead it employs a tapped delay line (see @ref{fig:tdc_principle}), 
fabricated in silicon as a series of identical buffers or inverters. The input of the line is connected 
to the Start signal, while the output of each buffer drives a latch disabled by the Stop signal. 
The later the Stop signal comes after Start, the more ones will be latched in, and the higher 
will be the output value, at least in @i{The Ideal World}. 

@float Figure,fig:tdc_principle
@center @image{drawings/tdc_principle, 8cm,,,.pdf}
@caption{Simplified schematic of a tapped delay line TDC.}
@end float

Unfortunately, in @i{The Real World}, PVT 
effects come into play, causing the delay introduced by each buffer to vary with temperature, 
voltage and between different chips. The TDC by Acam employs a clever trick to compensate for this 
delay spread. It has another delay line, with more or less identical silicon layout but with 
positive feedback, turning it into a ring oscillator. The frequency produced by this oscillator 
is continuously measured and compared against a reference value corresponding to the desired 
bin size. The resulting error signal drives a servo that controls the voltage powering both the 
oscillator and the measurement delay line(s) in such way that bin size stays constant (assuming 
that delays introduced by each of the buffers scale with very similar factors). This explains 
why the power circuitry for the TDC is so complex (3 LM1117 LDO regulators - IC6, IC89 and IC21). 
The servo output signal (PHASE) is PWM-modulated and after filtering in R17-C22-R16 and R20-C42-R22 
circuits, it produces a bias voltage on the ADJ pin of the regulators, which directly determines
their output voltages (Vadj = Vout - 1.25 V). The values of the voltage divider components and 
the large number of decoupling capacitors come from the TDC-GPX reference design provided by Acam. 

The TDC communicates with the FPGA using a simple asynchronous address/data bus, with 4 address 
bits and 28 data bits. Aside from standard signals (CS, RD, WR), the FPGA drives the TDC FIFO 
purge signal (TDC_ALUTRIGGER) and receives the Timestamp FIFO Empty and Error flags (TDC_EF and TDC_ERR).
Series resistors on TDC data lines are provided to match the impedance of the PCB traces, 
improving signal integrity and EMC performance. 

Note that the address inputs of the TDC are not driven by the FPGA, but by the SPI GPIO controller (MC23S17, ICxx).
This is due to lack of free pins in the FMC connector. Fortunately, the address value needs to be modified
only when setting up the TDC and it stays constant during data readout, having no impact on performance.

@section Output stages

Relevant files: @code{delay_channel.SchDoc}, @code{output_driver.SchDoc}, @code{drv_single_channel.SchDoc}.

The role of the FD's output stages is to:
@itemize
@item reduce the jitter and de-skew coarse output pulses produced by the FPGA,
@item adjust the fine part of the delay,
@item properly drive a 50 Ohm load.
@end itemize

The first task is done by the discrete LVPECL flip-flops (IC3). The D inputs of the FFs are
connected to the FPGA pins (output counter comparators), while the CLK inputs supply 4 low-skew
250 MHz clocks, synchronous with the FPGA's reference 125 MHz clock. This way, poor quality
pulses prouduced by the FPGA are retimed and deskewed, resulting with an output-to-output skew
of less than 100 ps and jitter level comparable to the PLL chip. 

Retimed output signals are afterwards fed to the delay lines (IC2, IC7). A SY89295 chip from
Micrel was used, mainly because of availabilty in QFN packages (PCB space constraints). 
The delay lines are configured by providing a 10-bit word to D9..D0 inputs and latching it in by asserting LEN input low. Value 0 corresponds to ~2.2 ns and 1023 to ~12.5 ns, giving
quite a lot of headroom (we need 4 ns range). The delay is reconfigured immediately after laching in a new value. All delay chips share
same data bus, which is arbitrated by the FPGA (again, due to lack of pins in the FMC connector). The price is higher minimum possible delay setpoint:
since updating a single chip takes 3 clock cycles (24 ns), the worst-case update time is 96 ns (so we lose 72 ns). Resistors R11 and R53 select the signalling
level for the control inputs (LVTTL). 

The differential signal is converted back to LVTTL by IC1 (SY100EPT23) and fed to a single ended driver IC25,
built using a fast high current operational amplifier AD8009. Resistors R69 and R71 set the gain to get 6 V peak
level on a high impedance load. R75 ensures proper biasing of the bipolar output stage of IC1. The opamp is powered from
a dedicated switched mode power supply (+8 V/-2 V). Amplified signal passes through the SSR switch SW1, serving the purpose 
of enabling/disabling the output in a rock-solid, glitch-proof way. D4 / F1 circuit ensures ESD/overcurrent/overvoltage protection. R72, together with
the opamp's output and SSR's series impedances form a 50 Ohm source termination. R65 ensures low state on the output when the card is disabled. 
The lowpass circuit R42/C49 makes sure the SSR is switched of and off with some dignity. IC26 buffers the output signal for driving feedback TDC input (calibration).
The D flip flop IC27 is a part of DDMTD-based calibration scheme. R66 and R34 constitute a voltage divider, bringing down the 6 V output of the opamp to a level
that is acceptable by LVC/AUP logic. Yet again, due to lack of pins, calibration flip flop outputs are ANDed together, making a trivial multiplexer (outputs are calibrated one-by-one,
while the rest is driven to 1). The output stage meets edge rising time requirement of 2 V/ns (thanks to extreme output voltage rise speed of AD8009 of 5.5 kV/us) for both 50 Ohm and high impedance loads and is capable of producing neat, clean pulses of 3 V level on 50 Ohms, suitable for directly driving TTL inputs (see @ref{fig:output_shape}).

@float Figure,fig:output_shape
@center @image{drawings/output_shape, 10cm,,,.png}
@caption{Shape of output pulse rising edge on a 50 Ohm load.}
@end float


@section Everything else

Relevant files: @code{FMC_Delay_1ns_4cha.SchDoc}.

Here are all other components that didn't end up in previous sections:
@itemize
@item SPI GPIO expander (IC19 - MCP23S17): drives seldom changing digital signals, saving some pins in the FMC
plug for more important purposes. The outputs driven are TDC address lines, output stage SSR enables,
calibration mode select and termination enable lines.
@item Buffers (IC12, IC28, IC29 - LVC1G125): ensure correct operation of all SPI peripherals by 
adapting 2.5 V LVCMOS levels from the FPGA to 3.3 V LVTTL,
@item Buffers (IC32, IC31 - LVC1G125): boost output current/levels of the FPGA for driving calibration
inputs (DDMTD clock and calibration TDC pulses), 
@item 1-Wire temperature sensor (IC13, DS18B20U+): measures the temperature of the output delay lines 
(used by on-the-fly delay drift compensation) and gives each board
an unique ID number.
@item Two LEDs and a configiuration EEPROM (IC22) - standard components of every FMC card. The EEPROM is also used for storage of calibration parameters.
@item Power supply: the FD includes two switching PSUs: a buck converter IC11 for +8 V / 600 mA supply and an inverting converter IC30, producing -2 V @ 600 mA. Both converters are solely for
powering the output stage opamps. 
@item Voltage supervisor IC36 (TPS3307-33) - ensures that the card is un-reset when all the supply voltages have stabilized. 
@item Slow power-on-reset circuit (R78, D1, C57).
@item TVS diode D7: additional overvoltage protection for outputs (when a high current DC voltage is connected, D7 clips it to a safe level, because P8V PSU is unable to sink current).
@end itemize

@chapter The VHDL

This chapter provides a brief description of the VHDL design of the FD core. For more detailed explanations, you may need to refer to the comments in the source code. The same applies for
descriptions of all interface signals.

@section Top Level
Relevant files: @code{fine_delay_core.vhd}.

@float Figure,fig:hdl_top
@center @image{drawings/fpga_diagram, 15cm,,,.pdf}
@caption{Block diagram of the FD VHDL core.}
@end float

The top level diagram of the FD core is shown in @ref{fig:hdl_top}, comprising the following components:
@itemize
@item ACAM timestamper unit, which produces time tags for the input pulses,
@item 4 FD channel drivers, which take these time tags, add the desired delay and produce a number pulses of given width and spacing,
@item DDR driver, placed outside the FD channel driver, since it is platform specific,
@item Ring buffer, providing timestamps of input/output pulses for the host driver,
@item Time base and reset generators, calibration logic and peripheral I/O cores (Onewire, etc.)
@end itemize
All of these are controlled by the host via a Wishbone bus. There are 6 Wishbone slaves in the design: 4 output register banks (one per each channel driver),
the main register bank (shared between all other sub-cores) and a 3rd-party OneWire core. Custom register banks were generated using the @code{wbgen2} tool. 
An SDB descriptor is provided for plug&play integration on the carrier with other cores. The core communicates with the outside world via the following interfaces.

Aside from Wishbone, the FD core provides direct timestamp I/O ports, which can be used to easily collect timestamps and trigger output pulses from other cores in your design.

@subsection Clocks & Time base
Relevant files: @code{fine_delay_core.vhd}, @code{fd_csync_generator.vhd}.

The FD core requires a number of clock signals to operate:
@itemize
@item @code{clk_ref_0_i} and @code{clk_ref_180_i}: Reference clock, coming from the AD9516 PLL. 
Since the FD's PLL provides only the @code{clk_ref_0_i} signal, the designer of the
carrier firmware must generate the shifted version with a platform-specific PLL/DCM component outside the FD core. This clock
references the entire pulse processing path (TDC core, output drivers, calibration logic & time base generator).
@item @code{clk_sys_i}: System clock, used by Wishbone busses, the direct timestamp I/O port and peripheral logic. Must not be faster than
@code{clk_ref_0_i}. Having a separate system clock domain simplifies integration with other IP cores on the same Wishbone bus.
@item @code{clk_dmtd_i}: DDMTD offset clock (close to 125 MHz) from the associated WR core. Used exclusively by the DDMTD calibration logic,
not necessary for normal operation of the card.
@end itemize

The time base for the FD core is provided by the @code{fd_csync_generator} unit. By ``time base'', we mean the the signals representing the core's internal notion of time, which are synchronous to the reference clock @code{clk_ref_0}:
@itemize
@item @code{csync_utc}: UTC/TAI seconds
@item @code{csync_coarse}: number of @code{clk_ref_0} cycles since beginning of the current second
@item @code{csync_pps}: Pulse-per-second signal, generated 3 cycles before beginning of each second. The 3-cycle advance is to accommodate for pipeline delays in the TDC and output drivers.
@end itemize

Timing-wise, the FD can work in one of these two modes:
@itemize 
@item @b{local time base} mode, where @code{clk_ref_0} oscillator is free running and the time counters 
are coarsely initialized by the host through the @code{TM_SECH}, @code{TM_SECL}, @code{TM_COARSE} and @code{TCR} registers. 
In this mode, the TDC input/output events cannot be related to other cores/devices, 
and the delay accuracy is as good as of the local oscillator (±2.5 ppm), 
which means worst case error of 2.5 ns for a delay setting of 1 ms).
@item @b{White Rabbit time base} mode, in which the reference clock is phase-locked to the WR master clock (by means of the SoftPLL
inside the WR Core) and the time base signals are following the second/cycles counters provided by the WR Core 
(all @code{tm_} prefixed signals in the top level).The accuracy is only
limited by the accuracy of the master clock. WR ensures inter-card synchronization better than 1 ns. 
For your convenience, the diagram on @ref{fig:wr_pll} shows the interaction between the hardware and the WR/FD cores.
@end itemize

@float Figure,fig:wr_pll
@center @image{drawings/wr_pll, 15cm,,,.pdf}
@caption{Operation of the FD core with White Rabbit as a time source.}
@end float

Mode selection is controlled by the @code{TCR} register and the @code{p_whiterabbit_fsm} state machin, 
which also provides the status of WR/local operation and can generate interrupts whenever the state 
of the synchronization source changes. When the WR link goes down, the FSM automatically
switches the card to local time base mode, retaining the previous value of time base counters 
(so the time will slowly drift away from the WR time scale, but not ``jump''). There is no 
automatic local-to-WR switchover available yet.

@section The TDC block
Relevant files: @code{fd_acam_timestamper.vhd}, @code{fd_acam_timestamp_postprocessor.vhd}, @code{fd_timestamper_stat_unit.vhd}.

The TDC controller interfaces with the ACAM TDC-GPX chip and does whatever is neccessary to output timestamps aligned with the FD core's time base, as fast (in terms of delay) as possible. That is:
@itemize
@item detection of input pulses, checking their width and generation of coarse (128 ns granularity) timestamps by taking a snapshot of an internal counter,
@item reading out the fine part from the ACAM,
@item merging these values together, aligning the result to the local timebase and outputting everything in a format digestible by the pulse generators.
@end itemize

@subsection TDC timing

Before we time tag any pulses, we need to make sure the TDC is referenced to something and the time shift between 
this something and the ACAM's internal time base is known (or better, fixed). Inside the TDC core, the local time base consists of:
@itemize
@item @code{utc_count} - seconds counter,
@item @code{coarse_count} - coarse start cycle counter (counting at TDC start signal rising edge in cycles of 128 ns),
@item @code{start_count} - start subcycle counter (0..15, reset with each start cycle of the TDC,
@item @code{subcycle_offset} - offset between the ACAM's and TDC core's timescales.
@end itemize

It's very simple if we work in local time base mode, as 
the counters need not be aligned to any other counters. The WR mode is a bit more complicated:
TDC start occurs every 16 reference clock ticks, but a PPS pulse from the Csync 
unit can come anytime. The most straightformward method here would be to reset the TDC start
generator at every PPS pulse, but it's unsafe (AD9516's output divider SYNC input is asynchronous).
The TDC core employs a simple trick here: when a PPS pulse comes, it stores the difference between the lowest 
bits of the Csync coarse counter and the subcycle counter (@code{subcycle_offset} signal in @code{p_start_subcycle_counter} process). This difference is added to the timestamps at the postprocessing stage.

@ref{fig:tdc_timing} shows the relations between the time base signals.
@float Figure,fig:tdc_timing
@center @image{drawings/tdc_time_base, 18cm,,,.jpg}
@caption{TDC core time base generation.}
@end float

@subsection Input stage and TDC control


@subsection Host interface

@subsection Timestamp processing

@node{ts_merging}
t
@section Output channels


@section Miscellanea
@subsection OneWire & I2C
@subsection SPI Master

@chapter Calibration

@subsection Output stage calibration
The role of this calibration mechanism is to minimize jitter of the output delay lines. 
Jitter is introduced when the delay added by an '89295 chip different from the desired tap setting.
For example, when the core requests a fine adjustment value of 7.5 ns, and the actual one is 8.5 ns, output pulses will
exhibit non-gaussian jitter of 1 ns peak-peak, which is far too high to meet the design specifications. PVT-induced drifts of 1 ns have been observed
for SY89295 chips used in our production cards.

The output stage calibration mechanism is depicted in @ref{fig:calib_output}. It works by feeding the output stage with 
calibration pulses and measuring the in-out delay of '89295 delays for different tap settings in order to find a point at which they
delay the signal by exactly 8 ns more than at tap setting of 0. The TDC, reconfigured in the I-mode (single ended start input and
4 single ended stop inputs, one per output) is reused as a calibrator (thanks to its' voltage adjusting PLL, we know that its definition of 8 ns
is not worse than of the reference oscillator). Precision better than 10 ps rms (single tap) is achieved by averaging multiple measurements.
This calibration is performed by the device driver every time the card is initialized. In order to speed it up, it assumes monotonicity of the output
stage (guaranteed by design) and instead of sweeping all possible tap counts, employs a simple divide-and-conquer algorithm.

@float Figure,fig:calib_output
@center @image{drawings/output_calibration, 12cm,,,.pdf}
@caption{Output stage jitter calibration mechanism.}
@end float

Note that while the calibration in progress, the output switch is disabled to stop our calibration pulses from reaching devices driven by the card. This unfortunately prevents
executing the calibration during runtime without risk of losing pulses. We provided an alternative mechanism to overcome this limitation, which
exploits the fact that since process and supply voltage remain constant during operation, only temperature has significant impact on the output stage delay.
A function of 8 ns tap delay error vs temperature was measured in the lab by cooling/heating up the card to temperatures between 30 and 90 degrees C with a Peltier cell
 and is used to relate the temperature and 8ns tap setting measured at the card startup with its' current temperature. Simple polynomial fitting allows for updating
the output stage scalefactor without disturbing the outputs with extra calibration pulses.

The same method (with full range sweeping instead of divide-and-conquer) is used to measure linearity (INL/DNL) of the delay lines during production test.

@subsection DDMTD I/O delay calibration

Careful readers may have noticed that the previous calibration process only minimizes jitter. The purpose of DDMTD calibration is to measure 
the end-to-end delay of an (almost) entire mezzanine. Figure @ref{fig:ddmtd_calibration} shows the calibration components:
@itemize
@item input of the TDC is fed with a square waveform of @code{clk_ref_0} / 144, simulating real input pulses of with fastest
possible input frequency (to speed up measurements) and some safety margin.
@item delay path is programmed to a minimum insertion delay of 500 ns. 
@item input and output pulses are sampled by another clock with two identical flip flops. Frequency of the samling clock is slightly offset with respect to 
@code{clk_ref_0} / 144 (in our case the offset is 1/16384). Flip flop outputs are hence @i{downconverted} versions of the in/out pulses and keep their timing relations, but
scaled down by a factor of 16384, so a delay of 10 picoseconds is seen as 16.384 ns. This is very easy to measure using a simple counter.
@end itemize

@float Figure,fig:ddmtd_calibration
@center @image{drawings/ddmtd_calibration, 10cm,,,.pdf}
@caption{End-to-end delay calibration using DDMTDs.}
@end float

Since the offset clock is produced by the PLL in the White Rabbit core, DDMTD calibration
is possible only with WR-enabled carriers. It is not done by default in the driver, but
can be run using @code{ddmtd_calibration} tool from the @code{software/tests/} subdirectory in the repo. 

Note that this method is still not ideal - it is prone to PVT differences between the calibration flip flops and it does not take into account the delays introduced by
the output cutoff and input selection switches. Therefore, production tests involve calibration with an external time interval meter. Tests performed on a batch of 80 cards
have shown that the error between DDMTD calibration mechanism and the external TIM did not exceed 800 ps.

For more information on DDMTD phase/time measurement techniques please refer to @ref{book:toms_msc}.

@chapter Long term stability

@chapter Carrier implementation example

This chapter shows how to implement the FD core on an FMC carrier, taking the production design of the SVEC VME carrier equipped with two Fine Delays as an example.


@appendix Register set  
@subsection Main registers
Wbgen2 texinfo documentation
@subsection Output stage registers
Wbgen2 texinfo documentation
@appendix References


@bye

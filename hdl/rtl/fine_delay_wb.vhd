---------------------------------------------------------------------------------------
-- Title          : Wishbone slave core for Fine Delay WB
---------------------------------------------------------------------------------------
-- File           : fine_delay_wb.vhd
-- Author         : auto-generated by wbgen2 from fine_delay_wb.wb
-- Created        : Mon May 30 19:41:22 2011
-- Standard       : VHDL'87
---------------------------------------------------------------------------------------
-- THIS FILE WAS GENERATED BY wbgen2 FROM SOURCE FILE fine_delay_wb.wb
-- DO NOT HAND-EDIT UNLESS IT'S ABSOLUTELY NECESSARY!
---------------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wbgen2_pkg.all;

use work.fd_wbgen2_pkg.all;


entity fine_delay_wb is
port (
  rst_n_i                                  : in     std_logic;
  wb_clk_i                                 : in     std_logic;
  wb_addr_i                                : in     std_logic_vector(4 downto 0);
  wb_data_i                                : in     std_logic_vector(31 downto 0);
  wb_data_o                                : out    std_logic_vector(31 downto 0);
  wb_cyc_i                                 : in     std_logic;
  wb_sel_i                                 : in     std_logic_vector(3 downto 0);
  wb_stb_i                                 : in     std_logic;
  wb_we_i                                  : in     std_logic;
  wb_ack_o                                 : out    std_logic;
  clk_ref_i                                : in     std_logic;
  regs_b                                   : inout  t_fd_registers
);
end fine_delay_wb;

architecture syn of fine_delay_wb is

signal fd_gcr_bypass_int                        : std_logic      ;
signal fd_gcr_bypass_sync0                      : std_logic      ;
signal fd_gcr_bypass_sync1                      : std_logic      ;
signal fd_gcr_input_en_int                      : std_logic      ;
signal fd_gcr_input_en_sync0                    : std_logic      ;
signal fd_gcr_input_en_sync1                    : std_logic      ;
signal fd_gcr_clr_stat_int                      : std_logic      ;
signal fd_gcr_clr_stat_int_delay                : std_logic      ;
signal fd_gcr_clr_stat_sync0                    : std_logic      ;
signal fd_gcr_clr_stat_sync1                    : std_logic      ;
signal fd_gcr_clr_stat_sync2                    : std_logic      ;
signal fd_tar_data_int_read                     : std_logic_vector(27 downto 0);
signal fd_tar_data_int_write                    : std_logic_vector(27 downto 0);
signal fd_tar_data_lw                           : std_logic      ;
signal fd_tar_data_lw_delay                     : std_logic      ;
signal fd_tar_data_lw_read_in_progress          : std_logic      ;
signal fd_tar_data_lw_s0                        : std_logic      ;
signal fd_tar_data_lw_s1                        : std_logic      ;
signal fd_tar_data_lw_s2                        : std_logic      ;
signal fd_tar_data_rwsel                        : std_logic      ;
signal fd_tar_addr_int                          : std_logic_vector(3 downto 0);
signal fd_tar_addr_swb                          : std_logic      ;
signal fd_tar_addr_swb_delay                    : std_logic      ;
signal fd_tar_addr_swb_s0                       : std_logic      ;
signal fd_tar_addr_swb_s1                       : std_logic      ;
signal fd_tar_addr_swb_s2                       : std_logic      ;
signal fd_tdcsr_write_int                       : std_logic      ;
signal fd_tdcsr_write_int_delay                 : std_logic      ;
signal fd_tdcsr_write_sync0                     : std_logic      ;
signal fd_tdcsr_write_sync1                     : std_logic      ;
signal fd_tdcsr_write_sync2                     : std_logic      ;
signal fd_tdcsr_read_int                        : std_logic      ;
signal fd_tdcsr_read_int_delay                  : std_logic      ;
signal fd_tdcsr_read_sync0                      : std_logic      ;
signal fd_tdcsr_read_sync1                      : std_logic      ;
signal fd_tdcsr_read_sync2                      : std_logic      ;
signal fd_tdcsr_err_sync0                       : std_logic      ;
signal fd_tdcsr_err_sync1                       : std_logic      ;
signal fd_tdcsr_int_sync0                       : std_logic      ;
signal fd_tdcsr_int_sync1                       : std_logic      ;
signal fd_tdcsr_load_sync0                      : std_logic      ;
signal fd_tdcsr_load_sync1                      : std_logic      ;
signal fd_tdcsr_empty_sync0                     : std_logic      ;
signal fd_tdcsr_empty_sync1                     : std_logic      ;
signal fd_tdcsr_start_dis_int                   : std_logic      ;
signal fd_tdcsr_start_dis_int_delay             : std_logic      ;
signal fd_tdcsr_start_dis_sync0                 : std_logic      ;
signal fd_tdcsr_start_dis_sync1                 : std_logic      ;
signal fd_tdcsr_start_dis_sync2                 : std_logic      ;
signal fd_tdcsr_start_en_int                    : std_logic      ;
signal fd_tdcsr_start_en_int_delay              : std_logic      ;
signal fd_tdcsr_start_en_sync0                  : std_logic      ;
signal fd_tdcsr_start_en_sync1                  : std_logic      ;
signal fd_tdcsr_start_en_sync2                  : std_logic      ;
signal fd_tdcsr_stop_dis_int                    : std_logic      ;
signal fd_tdcsr_stop_dis_int_delay              : std_logic      ;
signal fd_tdcsr_stop_dis_sync0                  : std_logic      ;
signal fd_tdcsr_stop_dis_sync1                  : std_logic      ;
signal fd_tdcsr_stop_dis_sync2                  : std_logic      ;
signal fd_tdcsr_stop_en_int                     : std_logic      ;
signal fd_tdcsr_stop_en_int_delay               : std_logic      ;
signal fd_tdcsr_stop_en_sync0                   : std_logic      ;
signal fd_tdcsr_stop_en_sync1                   : std_logic      ;
signal fd_tdcsr_stop_en_sync2                   : std_logic      ;
signal fd_dcr_dly_sel_wr_int                    : std_logic      ;
signal fd_dcr_dly_sel_wr_int_delay              : std_logic      ;
signal fd_dcr_dly_sel_wr_sync0                  : std_logic      ;
signal fd_dcr_dly_sel_wr_sync1                  : std_logic      ;
signal fd_dcr_dly_sel_wr_sync2                  : std_logic      ;
signal fd_dcr_dly_val_int                       : std_logic_vector(9 downto 0);
signal fd_dcr_dly_val_swb                       : std_logic      ;
signal fd_dcr_dly_val_swb_delay                 : std_logic      ;
signal fd_dcr_dly_val_swb_s0                    : std_logic      ;
signal fd_dcr_dly_val_swb_s1                    : std_logic      ;
signal fd_dcr_dly_val_swb_s2                    : std_logic      ;
signal fd_iecraw_int                            : std_logic_vector(31 downto 0);
signal fd_iecraw_lwb                            : std_logic      ;
signal fd_iecraw_lwb_delay                      : std_logic      ;
signal fd_iecraw_lwb_in_progress                : std_logic      ;
signal fd_iecraw_lwb_s0                         : std_logic      ;
signal fd_iecraw_lwb_s1                         : std_logic      ;
signal fd_iecraw_lwb_s2                         : std_logic      ;
signal fd_iectag_int                            : std_logic_vector(31 downto 0);
signal fd_iectag_lwb                            : std_logic      ;
signal fd_iectag_lwb_delay                      : std_logic      ;
signal fd_iectag_lwb_in_progress                : std_logic      ;
signal fd_iectag_lwb_s0                         : std_logic      ;
signal fd_iectag_lwb_s1                         : std_logic      ;
signal fd_iectag_lwb_s2                         : std_logic      ;
signal fd_iepd_int                              : std_logic_vector(7 downto 0);
signal fd_iepd_lwb                              : std_logic      ;
signal fd_iepd_lwb_delay                        : std_logic      ;
signal fd_iepd_lwb_in_progress                  : std_logic      ;
signal fd_iepd_lwb_s0                           : std_logic      ;
signal fd_iepd_lwb_s1                           : std_logic      ;
signal fd_iepd_lwb_s2                           : std_logic      ;
signal fd_pgcr_period_int                       : std_logic_vector(30 downto 0);
signal fd_pgcr_enable_int                       : std_logic      ;
signal fd_tsfifo_in_int                         : std_logic_vector(105 downto 0);
signal fd_tsfifo_out_int                        : std_logic_vector(105 downto 0);
signal fd_tsfifo_rdreq_int                      : std_logic      ;
signal fd_tsfifo_rdreq_int_d0                   : std_logic      ;
signal fd_tsfifo_full_int                       : std_logic      ;
signal fd_tsfifo_empty_int                      : std_logic      ;
signal ack_sreg                                 : std_logic_vector(9 downto 0);
signal rddata_reg                               : std_logic_vector(31 downto 0);
signal wrdata_reg                               : std_logic_vector(31 downto 0);
signal bwsel_reg                                : std_logic_vector(3 downto 0);
signal rwaddr_reg                               : std_logic_vector(4 downto 0);
signal ack_in_progress                          : std_logic      ;
signal wr_int                                   : std_logic      ;
signal rd_int                                   : std_logic      ;
signal bus_clock_int                            : std_logic      ;
signal allones                                  : std_logic_vector(31 downto 0);
signal allzeros                                 : std_logic_vector(31 downto 0);

begin
regs_b <= c_fd_registers_init_value;
-- Some internal signals assignments. For (foreseen) compatibility with other bus standards.
wrdata_reg <= wb_data_i;
bwsel_reg <= wb_sel_i;
bus_clock_int <= wb_clk_i;
rd_int <= wb_cyc_i and (wb_stb_i and (not wb_we_i));
wr_int <= wb_cyc_i and (wb_stb_i and wb_we_i);
allones <= (others => '1');
allzeros <= (others => '0');
-- 
-- Main register bank access process.
process (bus_clock_int, rst_n_i)
begin
  if (rst_n_i = '0') then 
    ack_sreg <= "0000000000";
    ack_in_progress <= '0';
    rddata_reg <= "00000000000000000000000000000000";
    regs_b.rstr_wr_o <= '0';
    fd_gcr_bypass_int <= '0';
    fd_gcr_input_en_int <= '0';
    fd_gcr_clr_stat_int <= '0';
    fd_gcr_clr_stat_int_delay <= '0';
    fd_tar_data_lw <= '0';
    fd_tar_data_lw_delay <= '0';
    fd_tar_data_lw_read_in_progress <= '0';
    fd_tar_data_rwsel <= '0';
    fd_tar_data_int_write <= "0000000000000000000000000000";
    fd_tar_addr_int <= "0000";
    fd_tar_addr_swb <= '0';
    fd_tar_addr_swb_delay <= '0';
    fd_tdcsr_write_int <= '0';
    fd_tdcsr_write_int_delay <= '0';
    fd_tdcsr_read_int <= '0';
    fd_tdcsr_read_int_delay <= '0';
    fd_tdcsr_start_dis_int <= '0';
    fd_tdcsr_start_dis_int_delay <= '0';
    fd_tdcsr_start_en_int <= '0';
    fd_tdcsr_start_en_int_delay <= '0';
    fd_tdcsr_stop_dis_int <= '0';
    fd_tdcsr_stop_dis_int_delay <= '0';
    fd_tdcsr_stop_en_int <= '0';
    fd_tdcsr_stop_en_int_delay <= '0';
    fd_dcr_dly_sel_wr_int <= '0';
    fd_dcr_dly_sel_wr_int_delay <= '0';
    fd_dcr_dly_val_int <= "0000000000";
    fd_dcr_dly_val_swb <= '0';
    fd_dcr_dly_val_swb_delay <= '0';
    regs_b.gpsr_cs_pll_wr_o <= '0';
    regs_b.gpsr_cs_gpio_wr_o <= '0';
    regs_b.gpsr_sclk_wr_o <= '0';
    regs_b.gpsr_mosi_wr_o <= '0';
    regs_b.gpcr_cs_pll_wr_o <= '0';
    regs_b.gpcr_cs_gpio_wr_o <= '0';
    regs_b.gpcr_sclk_wr_o <= '0';
    regs_b.gpcr_mosi_wr_o <= '0';
    fd_iecraw_lwb <= '0';
    fd_iecraw_lwb_delay <= '0';
    fd_iecraw_lwb_in_progress <= '0';
    fd_iectag_lwb <= '0';
    fd_iectag_lwb_delay <= '0';
    fd_iectag_lwb_in_progress <= '0';
    fd_iepd_lwb <= '0';
    fd_iepd_lwb_delay <= '0';
    fd_iepd_lwb_in_progress <= '0';
    fd_pgcr_period_int <= "0000000000000000000000000000000";
    fd_pgcr_enable_int <= '0';
    fd_tsfifo_rdreq_int <= '0';
  elsif rising_edge(bus_clock_int) then
-- advance the ACK generator shift register
    ack_sreg(8 downto 0) <= ack_sreg(9 downto 1);
    ack_sreg(9) <= '0';
    if (ack_in_progress = '1') then
      if (ack_sreg(0) = '1') then
        regs_b.rstr_wr_o <= '0';
        regs_b.gpsr_cs_pll_wr_o <= '0';
        regs_b.gpsr_cs_gpio_wr_o <= '0';
        regs_b.gpsr_sclk_wr_o <= '0';
        regs_b.gpsr_mosi_wr_o <= '0';
        regs_b.gpcr_cs_pll_wr_o <= '0';
        regs_b.gpcr_cs_gpio_wr_o <= '0';
        regs_b.gpcr_sclk_wr_o <= '0';
        regs_b.gpcr_mosi_wr_o <= '0';
        ack_in_progress <= '0';
      else
        regs_b.rstr_wr_o <= '0';
        fd_gcr_clr_stat_int <= fd_gcr_clr_stat_int_delay;
        fd_gcr_clr_stat_int_delay <= '0';
        fd_tar_data_lw <= fd_tar_data_lw_delay;
        fd_tar_data_lw_delay <= '0';
        if ((ack_sreg(1) = '1') and (fd_tar_data_lw_read_in_progress = '1')) then
          rddata_reg(27 downto 0) <= fd_tar_data_int_read;
          fd_tar_data_lw_read_in_progress <= '0';
        end if;
        fd_tar_addr_swb <= fd_tar_addr_swb_delay;
        fd_tar_addr_swb_delay <= '0';
        fd_tdcsr_write_int <= fd_tdcsr_write_int_delay;
        fd_tdcsr_write_int_delay <= '0';
        fd_tdcsr_read_int <= fd_tdcsr_read_int_delay;
        fd_tdcsr_read_int_delay <= '0';
        fd_tdcsr_start_dis_int <= fd_tdcsr_start_dis_int_delay;
        fd_tdcsr_start_dis_int_delay <= '0';
        fd_tdcsr_start_en_int <= fd_tdcsr_start_en_int_delay;
        fd_tdcsr_start_en_int_delay <= '0';
        fd_tdcsr_stop_dis_int <= fd_tdcsr_stop_dis_int_delay;
        fd_tdcsr_stop_dis_int_delay <= '0';
        fd_tdcsr_stop_en_int <= fd_tdcsr_stop_en_int_delay;
        fd_tdcsr_stop_en_int_delay <= '0';
        fd_dcr_dly_sel_wr_int <= fd_dcr_dly_sel_wr_int_delay;
        fd_dcr_dly_sel_wr_int_delay <= '0';
        fd_dcr_dly_val_swb <= fd_dcr_dly_val_swb_delay;
        fd_dcr_dly_val_swb_delay <= '0';
        regs_b.gpsr_cs_pll_wr_o <= '0';
        regs_b.gpsr_cs_gpio_wr_o <= '0';
        regs_b.gpsr_sclk_wr_o <= '0';
        regs_b.gpsr_mosi_wr_o <= '0';
        regs_b.gpcr_cs_pll_wr_o <= '0';
        regs_b.gpcr_cs_gpio_wr_o <= '0';
        regs_b.gpcr_sclk_wr_o <= '0';
        regs_b.gpcr_mosi_wr_o <= '0';
        fd_iecraw_lwb <= fd_iecraw_lwb_delay;
        fd_iecraw_lwb_delay <= '0';
        if ((ack_sreg(1) = '1') and (fd_iecraw_lwb_in_progress = '1')) then
          rddata_reg(31 downto 0) <= fd_iecraw_int;
          fd_iecraw_lwb_in_progress <= '0';
        end if;
        fd_iectag_lwb <= fd_iectag_lwb_delay;
        fd_iectag_lwb_delay <= '0';
        if ((ack_sreg(1) = '1') and (fd_iectag_lwb_in_progress = '1')) then
          rddata_reg(31 downto 0) <= fd_iectag_int;
          fd_iectag_lwb_in_progress <= '0';
        end if;
        fd_iepd_lwb <= fd_iepd_lwb_delay;
        fd_iepd_lwb_delay <= '0';
        if ((ack_sreg(1) = '1') and (fd_iepd_lwb_in_progress = '1')) then
          rddata_reg(7 downto 0) <= fd_iepd_int;
          fd_iepd_lwb_in_progress <= '0';
        end if;
      end if;
    else
      if ((wb_cyc_i = '1') and (wb_stb_i = '1')) then
        case rwaddr_reg(4 downto 0) is
        when "00000" => 
          if (wb_we_i = '1') then
            regs_b.rstr_wr_o <= '1';
          else
            rddata_reg(0) <= 'X';
            rddata_reg(1) <= 'X';
            rddata_reg(2) <= 'X';
            rddata_reg(3) <= 'X';
            rddata_reg(4) <= 'X';
            rddata_reg(5) <= 'X';
            rddata_reg(6) <= 'X';
            rddata_reg(7) <= 'X';
            rddata_reg(8) <= 'X';
            rddata_reg(9) <= 'X';
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "00001" => 
          if (wb_we_i = '1') then
            fd_gcr_bypass_int <= wrdata_reg(0);
            fd_gcr_input_en_int <= wrdata_reg(1);
            fd_gcr_clr_stat_int <= wrdata_reg(2);
            fd_gcr_clr_stat_int_delay <= wrdata_reg(2);
          else
            rddata_reg(0) <= fd_gcr_bypass_int;
            rddata_reg(1) <= fd_gcr_input_en_int;
            rddata_reg(3) <= 'X';
            rddata_reg(4) <= 'X';
            rddata_reg(5) <= 'X';
            rddata_reg(6) <= 'X';
            rddata_reg(7) <= 'X';
            rddata_reg(8) <= 'X';
            rddata_reg(9) <= 'X';
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(4) <= '1';
          ack_in_progress <= '1';
        when "00010" => 
          if (wb_we_i = '1') then
            fd_tar_data_int_write <= wrdata_reg(27 downto 0);
            fd_tar_data_lw <= '1';
            fd_tar_data_lw_delay <= '1';
            fd_tar_data_lw_read_in_progress <= '0';
            fd_tar_data_rwsel <= '1';
            fd_tar_addr_int <= wrdata_reg(31 downto 28);
            fd_tar_addr_swb <= '1';
            fd_tar_addr_swb_delay <= '1';
          else
            fd_tar_data_lw <= '1';
            fd_tar_data_lw_delay <= '1';
            fd_tar_data_lw_read_in_progress <= '1';
            fd_tar_data_rwsel <= '0';
            rddata_reg(31 downto 28) <= fd_tar_addr_int;
          end if;
          ack_sreg(5) <= '1';
          ack_in_progress <= '1';
        when "00011" => 
          if (wb_we_i = '1') then
            fd_tdcsr_write_int <= wrdata_reg(0);
            fd_tdcsr_write_int_delay <= wrdata_reg(0);
            fd_tdcsr_read_int <= wrdata_reg(1);
            fd_tdcsr_read_int_delay <= wrdata_reg(1);
            fd_tdcsr_start_dis_int <= wrdata_reg(6);
            fd_tdcsr_start_dis_int_delay <= wrdata_reg(6);
            fd_tdcsr_start_en_int <= wrdata_reg(7);
            fd_tdcsr_start_en_int_delay <= wrdata_reg(7);
            fd_tdcsr_stop_dis_int <= wrdata_reg(8);
            fd_tdcsr_stop_dis_int_delay <= wrdata_reg(8);
            fd_tdcsr_stop_en_int <= wrdata_reg(9);
            fd_tdcsr_stop_en_int_delay <= wrdata_reg(9);
          else
            rddata_reg(2) <= fd_tdcsr_err_sync1;
            rddata_reg(3) <= fd_tdcsr_int_sync1;
            rddata_reg(4) <= fd_tdcsr_load_sync1;
            rddata_reg(5) <= fd_tdcsr_empty_sync1;
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(4) <= '1';
          ack_in_progress <= '1';
        when "00100" => 
          if (wb_we_i = '1') then
            fd_dcr_dly_sel_wr_int <= '1';
            fd_dcr_dly_sel_wr_int_delay <= '1';
            fd_dcr_dly_val_int <= wrdata_reg(13 downto 4);
            fd_dcr_dly_val_swb <= '1';
            fd_dcr_dly_val_swb_delay <= '1';
          else
            rddata_reg(13 downto 4) <= fd_dcr_dly_val_int;
            rddata_reg(0) <= 'X';
            rddata_reg(1) <= 'X';
            rddata_reg(2) <= 'X';
            rddata_reg(3) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(3) <= '1';
          ack_in_progress <= '1';
        when "00101" => 
          if (wb_we_i = '1') then
            regs_b.gpsr_cs_pll_wr_o <= '1';
            regs_b.gpsr_cs_gpio_wr_o <= '1';
            regs_b.gpsr_sclk_wr_o <= '1';
            regs_b.gpsr_mosi_wr_o <= '1';
          else
            rddata_reg(0) <= 'X';
            rddata_reg(1) <= 'X';
            rddata_reg(2) <= 'X';
            rddata_reg(3) <= 'X';
            rddata_reg(4) <= 'X';
            rddata_reg(5) <= 'X';
            rddata_reg(6) <= 'X';
            rddata_reg(7) <= 'X';
            rddata_reg(8) <= 'X';
            rddata_reg(9) <= 'X';
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "00110" => 
          if (wb_we_i = '1') then
            regs_b.gpcr_cs_pll_wr_o <= '1';
            regs_b.gpcr_cs_gpio_wr_o <= '1';
            regs_b.gpcr_sclk_wr_o <= '1';
            regs_b.gpcr_mosi_wr_o <= '1';
          else
            rddata_reg(0) <= 'X';
            rddata_reg(1) <= 'X';
            rddata_reg(2) <= 'X';
            rddata_reg(3) <= 'X';
            rddata_reg(4) <= 'X';
            rddata_reg(5) <= 'X';
            rddata_reg(6) <= 'X';
            rddata_reg(7) <= 'X';
            rddata_reg(8) <= 'X';
            rddata_reg(9) <= 'X';
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "00111" => 
          if (wb_we_i = '1') then
          else
            rddata_reg(0) <= regs_b.gprr_miso_i;
            rddata_reg(1) <= 'X';
            rddata_reg(2) <= 'X';
            rddata_reg(3) <= 'X';
            rddata_reg(4) <= 'X';
            rddata_reg(5) <= 'X';
            rddata_reg(6) <= 'X';
            rddata_reg(7) <= 'X';
            rddata_reg(8) <= 'X';
            rddata_reg(9) <= 'X';
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "01000" => 
          if (wb_we_i = '1') then
          else
            fd_iecraw_lwb <= '1';
            fd_iecraw_lwb_delay <= '1';
            fd_iecraw_lwb_in_progress <= '1';
          end if;
          ack_sreg(5) <= '1';
          ack_in_progress <= '1';
        when "01001" => 
          if (wb_we_i = '1') then
          else
            fd_iectag_lwb <= '1';
            fd_iectag_lwb_delay <= '1';
            fd_iectag_lwb_in_progress <= '1';
          end if;
          ack_sreg(5) <= '1';
          ack_in_progress <= '1';
        when "01010" => 
          if (wb_we_i = '1') then
          else
            fd_iepd_lwb <= '1';
            fd_iepd_lwb_delay <= '1';
            fd_iepd_lwb_in_progress <= '1';
            rddata_reg(8) <= 'X';
            rddata_reg(9) <= 'X';
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(16) <= 'X';
            rddata_reg(17) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(5) <= '1';
          ack_in_progress <= '1';
        when "01011" => 
          if (wb_we_i = '1') then
            fd_pgcr_period_int <= wrdata_reg(30 downto 0);
            fd_pgcr_enable_int <= wrdata_reg(31);
          else
            rddata_reg(30 downto 0) <= fd_pgcr_period_int;
            rddata_reg(31) <= fd_pgcr_enable_int;
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "01100" => 
          if (wb_we_i = '1') then
          else
            if (fd_tsfifo_rdreq_int_d0 = '0') then
              fd_tsfifo_rdreq_int <= not fd_tsfifo_rdreq_int;
            else
              rddata_reg(31 downto 0) <= fd_tsfifo_out_int(31 downto 0);
              ack_in_progress <= '1';
              ack_sreg(0) <= '1';
            end if;
          end if;
        when "01101" => 
          if (wb_we_i = '1') then
          else
            rddata_reg(27 downto 0) <= fd_tsfifo_out_int(59 downto 32);
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "01110" => 
          if (wb_we_i = '1') then
          else
            rddata_reg(22 downto 0) <= fd_tsfifo_out_int(82 downto 60);
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "01111" => 
          if (wb_we_i = '1') then
          else
            rddata_reg(22 downto 0) <= fd_tsfifo_out_int(105 downto 83);
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "10000" => 
          if (wb_we_i = '1') then
          else
            rddata_reg(16) <= fd_tsfifo_full_int;
            rddata_reg(17) <= fd_tsfifo_empty_int;
            rddata_reg(0) <= 'X';
            rddata_reg(1) <= 'X';
            rddata_reg(2) <= 'X';
            rddata_reg(3) <= 'X';
            rddata_reg(4) <= 'X';
            rddata_reg(5) <= 'X';
            rddata_reg(6) <= 'X';
            rddata_reg(7) <= 'X';
            rddata_reg(8) <= 'X';
            rddata_reg(9) <= 'X';
            rddata_reg(10) <= 'X';
            rddata_reg(11) <= 'X';
            rddata_reg(12) <= 'X';
            rddata_reg(13) <= 'X';
            rddata_reg(14) <= 'X';
            rddata_reg(15) <= 'X';
            rddata_reg(18) <= 'X';
            rddata_reg(19) <= 'X';
            rddata_reg(20) <= 'X';
            rddata_reg(21) <= 'X';
            rddata_reg(22) <= 'X';
            rddata_reg(23) <= 'X';
            rddata_reg(24) <= 'X';
            rddata_reg(25) <= 'X';
            rddata_reg(26) <= 'X';
            rddata_reg(27) <= 'X';
            rddata_reg(28) <= 'X';
            rddata_reg(29) <= 'X';
            rddata_reg(30) <= 'X';
            rddata_reg(31) <= 'X';
          end if;
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when others =>
-- prevent the slave from hanging the bus on invalid address
          ack_in_progress <= '1';
          ack_sreg(0) <= '1';
        end case;
      end if;
    end if;
  end if;
end process;


-- Drive the data output bus
wb_data_o <= rddata_reg;
-- Reset trigger
-- pass-through field: Reset trigger in register: Reset Register
regs_b.rstr_o <= wrdata_reg(31 downto 0);
-- Bypass delay block
-- synchronizer chain for field : Bypass delay block (type RW/RO, bus_clock_int <-> clk_ref_i)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.gcr_bypass_o <= '0';
    fd_gcr_bypass_sync0 <= '0';
    fd_gcr_bypass_sync1 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_gcr_bypass_sync0 <= fd_gcr_bypass_int;
    fd_gcr_bypass_sync1 <= fd_gcr_bypass_sync0;
    regs_b.gcr_bypass_o <= fd_gcr_bypass_sync1;
  end if;
end process;


-- Enabe trigger input
-- synchronizer chain for field : Enabe trigger input (type RW/RO, bus_clock_int <-> clk_ref_i)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.gcr_input_en_o <= '0';
    fd_gcr_input_en_sync0 <= '0';
    fd_gcr_input_en_sync1 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_gcr_input_en_sync0 <= fd_gcr_input_en_int;
    fd_gcr_input_en_sync1 <= fd_gcr_input_en_sync0;
    regs_b.gcr_input_en_o <= fd_gcr_input_en_sync1;
  end if;
end process;


-- Clear statistics counters
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.gcr_clr_stat_o <= '0';
    fd_gcr_clr_stat_sync0 <= '0';
    fd_gcr_clr_stat_sync1 <= '0';
    fd_gcr_clr_stat_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_gcr_clr_stat_sync0 <= fd_gcr_clr_stat_int;
    fd_gcr_clr_stat_sync1 <= fd_gcr_clr_stat_sync0;
    fd_gcr_clr_stat_sync2 <= fd_gcr_clr_stat_sync1;
    regs_b.gcr_clr_stat_o <= fd_gcr_clr_stat_sync2 and (not fd_gcr_clr_stat_sync1);
  end if;
end process;


-- DATA
-- asynchronous std_logic_vector register : DATA (type RW/WO, clk_ref_i <-> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_tar_data_lw_s0 <= '0';
    fd_tar_data_lw_s1 <= '0';
    fd_tar_data_lw_s2 <= '0';
    regs_b.tar_data_o <= "0000000000000000000000000000";
    regs_b.tar_data_load_o <= '0';
    fd_tar_data_int_read <= "0000000000000000000000000000";
  elsif rising_edge(clk_ref_i) then
    fd_tar_data_lw_s0 <= fd_tar_data_lw;
    fd_tar_data_lw_s1 <= fd_tar_data_lw_s0;
    fd_tar_data_lw_s2 <= fd_tar_data_lw_s1;
    if ((fd_tar_data_lw_s2 = '0') and (fd_tar_data_lw_s1 = '1')) then
      if (fd_tar_data_rwsel = '1') then
        regs_b.tar_data_o <= fd_tar_data_int_write;
        regs_b.tar_data_load_o <= '1';
      else
        regs_b.tar_data_load_o <= '0';
        fd_tar_data_int_read <= regs_b.tar_data_i;
      end if;
    else
      regs_b.tar_data_load_o <= '0';
    end if;
  end if;
end process;


-- ADDR
-- asynchronous std_logic_vector register : ADDR (type RW/RO, clk_ref_i <-> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_tar_addr_swb_s0 <= '0';
    fd_tar_addr_swb_s1 <= '0';
    fd_tar_addr_swb_s2 <= '0';
    regs_b.tar_addr_o <= "0000";
  elsif rising_edge(clk_ref_i) then
    fd_tar_addr_swb_s0 <= fd_tar_addr_swb;
    fd_tar_addr_swb_s1 <= fd_tar_addr_swb_s0;
    fd_tar_addr_swb_s2 <= fd_tar_addr_swb_s1;
    if ((fd_tar_addr_swb_s2 = '0') and (fd_tar_addr_swb_s1 = '1')) then
      regs_b.tar_addr_o <= fd_tar_addr_int;
    end if;
  end if;
end process;


-- Start TDC write
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.tdcsr_write_o <= '0';
    fd_tdcsr_write_sync0 <= '0';
    fd_tdcsr_write_sync1 <= '0';
    fd_tdcsr_write_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_write_sync0 <= fd_tdcsr_write_int;
    fd_tdcsr_write_sync1 <= fd_tdcsr_write_sync0;
    fd_tdcsr_write_sync2 <= fd_tdcsr_write_sync1;
    regs_b.tdcsr_write_o <= fd_tdcsr_write_sync2 and (not fd_tdcsr_write_sync1);
  end if;
end process;


-- Start TDC read
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.tdcsr_read_o <= '0';
    fd_tdcsr_read_sync0 <= '0';
    fd_tdcsr_read_sync1 <= '0';
    fd_tdcsr_read_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_read_sync0 <= fd_tdcsr_read_int;
    fd_tdcsr_read_sync1 <= fd_tdcsr_read_sync0;
    fd_tdcsr_read_sync2 <= fd_tdcsr_read_sync1;
    regs_b.tdcsr_read_o <= fd_tdcsr_read_sync2 and (not fd_tdcsr_read_sync1);
  end if;
end process;


-- Error flag
-- synchronizer chain for field : Error flag (type RO/WO, clk_ref_i -> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_tdcsr_err_sync0 <= '0';
    fd_tdcsr_err_sync1 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_err_sync0 <= regs_b.tdcsr_err_i;
    fd_tdcsr_err_sync1 <= fd_tdcsr_err_sync0;
  end if;
end process;


-- Interrupt flag
-- synchronizer chain for field : Interrupt flag (type RO/WO, clk_ref_i -> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_tdcsr_int_sync0 <= '0';
    fd_tdcsr_int_sync1 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_int_sync0 <= regs_b.tdcsr_int_i;
    fd_tdcsr_int_sync1 <= fd_tdcsr_int_sync0;
  end if;
end process;


-- Load flag
-- synchronizer chain for field : Load flag (type RO/WO, clk_ref_i -> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_tdcsr_load_sync0 <= '0';
    fd_tdcsr_load_sync1 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_load_sync0 <= regs_b.tdcsr_load_i;
    fd_tdcsr_load_sync1 <= fd_tdcsr_load_sync0;
  end if;
end process;


-- Empty flag
-- synchronizer chain for field : Empty flag (type RO/WO, clk_ref_i -> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_tdcsr_empty_sync0 <= '0';
    fd_tdcsr_empty_sync1 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_empty_sync0 <= regs_b.tdcsr_empty_i;
    fd_tdcsr_empty_sync1 <= fd_tdcsr_empty_sync0;
  end if;
end process;


-- Start disable
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.tdcsr_start_dis_o <= '0';
    fd_tdcsr_start_dis_sync0 <= '0';
    fd_tdcsr_start_dis_sync1 <= '0';
    fd_tdcsr_start_dis_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_start_dis_sync0 <= fd_tdcsr_start_dis_int;
    fd_tdcsr_start_dis_sync1 <= fd_tdcsr_start_dis_sync0;
    fd_tdcsr_start_dis_sync2 <= fd_tdcsr_start_dis_sync1;
    regs_b.tdcsr_start_dis_o <= fd_tdcsr_start_dis_sync2 and (not fd_tdcsr_start_dis_sync1);
  end if;
end process;


-- Start enable
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.tdcsr_start_en_o <= '0';
    fd_tdcsr_start_en_sync0 <= '0';
    fd_tdcsr_start_en_sync1 <= '0';
    fd_tdcsr_start_en_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_start_en_sync0 <= fd_tdcsr_start_en_int;
    fd_tdcsr_start_en_sync1 <= fd_tdcsr_start_en_sync0;
    fd_tdcsr_start_en_sync2 <= fd_tdcsr_start_en_sync1;
    regs_b.tdcsr_start_en_o <= fd_tdcsr_start_en_sync2 and (not fd_tdcsr_start_en_sync1);
  end if;
end process;


-- Start disable
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.tdcsr_stop_dis_o <= '0';
    fd_tdcsr_stop_dis_sync0 <= '0';
    fd_tdcsr_stop_dis_sync1 <= '0';
    fd_tdcsr_stop_dis_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_stop_dis_sync0 <= fd_tdcsr_stop_dis_int;
    fd_tdcsr_stop_dis_sync1 <= fd_tdcsr_stop_dis_sync0;
    fd_tdcsr_stop_dis_sync2 <= fd_tdcsr_stop_dis_sync1;
    regs_b.tdcsr_stop_dis_o <= fd_tdcsr_stop_dis_sync2 and (not fd_tdcsr_stop_dis_sync1);
  end if;
end process;


-- Start enable
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_b.tdcsr_stop_en_o <= '0';
    fd_tdcsr_stop_en_sync0 <= '0';
    fd_tdcsr_stop_en_sync1 <= '0';
    fd_tdcsr_stop_en_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_tdcsr_stop_en_sync0 <= fd_tdcsr_stop_en_int;
    fd_tdcsr_stop_en_sync1 <= fd_tdcsr_stop_en_sync0;
    fd_tdcsr_stop_en_sync2 <= fd_tdcsr_stop_en_sync1;
    regs_b.tdcsr_stop_en_o <= fd_tdcsr_stop_en_sync2 and (not fd_tdcsr_stop_en_sync1);
  end if;
end process;


-- Delay line select
-- pass-through field: Delay line select in register: Delay Control Register
regs_b.dcr_dly_sel_o <= wrdata_reg(3 downto 0);
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_dcr_dly_sel_wr_sync0 <= '0';
    fd_dcr_dly_sel_wr_sync1 <= '0';
    fd_dcr_dly_sel_wr_sync2 <= '0';
  elsif rising_edge(clk_ref_i) then
    fd_dcr_dly_sel_wr_sync0 <= fd_dcr_dly_sel_wr_int;
    fd_dcr_dly_sel_wr_sync1 <= fd_dcr_dly_sel_wr_sync0;
    fd_dcr_dly_sel_wr_sync2 <= fd_dcr_dly_sel_wr_sync1;
    regs_b.dcr_dly_sel_wr_o <= fd_dcr_dly_sel_wr_sync1 and (not fd_dcr_dly_sel_wr_sync2);
  end if;
end process;


-- Delay value
-- asynchronous std_logic_vector register : Delay value (type RW/RO, clk_ref_i <-> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_dcr_dly_val_swb_s0 <= '0';
    fd_dcr_dly_val_swb_s1 <= '0';
    fd_dcr_dly_val_swb_s2 <= '0';
    regs_b.dcr_dly_val_o <= "0000000000";
  elsif rising_edge(clk_ref_i) then
    fd_dcr_dly_val_swb_s0 <= fd_dcr_dly_val_swb;
    fd_dcr_dly_val_swb_s1 <= fd_dcr_dly_val_swb_s0;
    fd_dcr_dly_val_swb_s2 <= fd_dcr_dly_val_swb_s1;
    if ((fd_dcr_dly_val_swb_s2 = '0') and (fd_dcr_dly_val_swb_s1 = '1')) then
      regs_b.dcr_dly_val_o <= fd_dcr_dly_val_int;
    end if;
  end if;
end process;


-- SPI PLL chip select
-- pass-through field: SPI PLL chip select in register: GPIO set register
regs_b.gpsr_cs_pll_o <= wrdata_reg(0);
-- SPI GPIO chip select
-- pass-through field: SPI GPIO chip select in register: GPIO set register
regs_b.gpsr_cs_gpio_o <= wrdata_reg(1);
-- SPI SCLK
-- pass-through field: SPI SCLK in register: GPIO set register
regs_b.gpsr_sclk_o <= wrdata_reg(2);
-- SPI MOSI
-- pass-through field: SPI MOSI in register: GPIO set register
regs_b.gpsr_mosi_o <= wrdata_reg(3);
-- SPI PLL chip select
-- pass-through field: SPI PLL chip select in register: GPIO clear register
regs_b.gpcr_cs_pll_o <= wrdata_reg(0);
-- SPI GPIO chip select
-- pass-through field: SPI GPIO chip select in register: GPIO clear register
regs_b.gpcr_cs_gpio_o <= wrdata_reg(1);
-- SPI SCLK
-- pass-through field: SPI SCLK in register: GPIO clear register
regs_b.gpcr_sclk_o <= wrdata_reg(2);
-- SPI MOSI
-- pass-through field: SPI MOSI in register: GPIO clear register
regs_b.gpcr_mosi_o <= wrdata_reg(3);
-- SPI MISO
-- Number of raw events
-- asynchronous std_logic_vector register : Number of raw events (type RO/WO, clk_ref_i <-> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_iecraw_lwb_s0 <= '0';
    fd_iecraw_lwb_s1 <= '0';
    fd_iecraw_lwb_s2 <= '0';
    fd_iecraw_int <= "00000000000000000000000000000000";
  elsif rising_edge(clk_ref_i) then
    fd_iecraw_lwb_s0 <= fd_iecraw_lwb;
    fd_iecraw_lwb_s1 <= fd_iecraw_lwb_s0;
    fd_iecraw_lwb_s2 <= fd_iecraw_lwb_s1;
    if ((fd_iecraw_lwb_s1 = '1') and (fd_iecraw_lwb_s2 = '0')) then
      fd_iecraw_int <= regs_b.iecraw_i;
    end if;
  end if;
end process;


-- Number of tagged events
-- asynchronous std_logic_vector register : Number of tagged events (type RO/WO, clk_ref_i <-> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_iectag_lwb_s0 <= '0';
    fd_iectag_lwb_s1 <= '0';
    fd_iectag_lwb_s2 <= '0';
    fd_iectag_int <= "00000000000000000000000000000000";
  elsif rising_edge(clk_ref_i) then
    fd_iectag_lwb_s0 <= fd_iectag_lwb;
    fd_iectag_lwb_s1 <= fd_iectag_lwb_s0;
    fd_iectag_lwb_s2 <= fd_iectag_lwb_s1;
    if ((fd_iectag_lwb_s1 = '1') and (fd_iectag_lwb_s2 = '0')) then
      fd_iectag_int <= regs_b.iectag_i;
    end if;
  end if;
end process;


-- Processing delay
-- asynchronous std_logic_vector register : Processing delay (type RO/WO, clk_ref_i <-> bus_clock_int)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_iepd_lwb_s0 <= '0';
    fd_iepd_lwb_s1 <= '0';
    fd_iepd_lwb_s2 <= '0';
    fd_iepd_int <= "00000000";
  elsif rising_edge(clk_ref_i) then
    fd_iepd_lwb_s0 <= fd_iepd_lwb;
    fd_iepd_lwb_s1 <= fd_iepd_lwb_s0;
    fd_iepd_lwb_s2 <= fd_iepd_lwb_s1;
    if ((fd_iepd_lwb_s1 = '1') and (fd_iepd_lwb_s2 = '0')) then
      fd_iepd_int <= regs_b.iepd_i;
    end if;
  end if;
end process;


-- Pulse period
regs_b.pgcr_period_o <= fd_pgcr_period_int;
-- Enable
regs_b.pgcr_enable_o <= fd_pgcr_enable_int;
-- extra code for reg/fifo/mem: Timestamp FIFO
fd_tsfifo_in_int(31 downto 0) <= regs_b.tsfifo_utc_i;
fd_tsfifo_in_int(59 downto 32) <= regs_b.tsfifo_coarse_i;
fd_tsfifo_in_int(82 downto 60) <= regs_b.tsfifo_frac_i;
fd_tsfifo_in_int(105 downto 83) <= regs_b.tsfifo_frac_raw_i;
fd_tsfifo_INST : wbgen2_fifo_async
  generic map (
    g_size               => 512,
    g_width              => 106,
    g_usedw_size         => 9
  )
  port map (
    wr_req_i             => regs_b.tsfifo_wr_req_i,
    wr_full_o            => regs_b.tsfifo_wr_full_o,
    rd_full_o            => fd_tsfifo_full_int,
    rd_empty_o           => fd_tsfifo_empty_int,
    rd_usedw_o           => open,
    rd_req_i             => fd_tsfifo_rdreq_int,
    wr_clk_i             => clk_ref_i,
    rd_clk_i             => bus_clock_int,
    wr_data_i            => fd_tsfifo_in_int,
    rd_data_o            => fd_tsfifo_out_int
  );

-- extra code for reg/fifo/mem: FIFO 'Timestamp FIFO' data output register 0
process (bus_clock_int, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fd_tsfifo_rdreq_int_d0 <= '0';
  elsif rising_edge(bus_clock_int) then
    fd_tsfifo_rdreq_int_d0 <= fd_tsfifo_rdreq_int;
  end if;
end process;


-- extra code for reg/fifo/mem: FIFO 'Timestamp FIFO' data output register 1
-- extra code for reg/fifo/mem: FIFO 'Timestamp FIFO' data output register 2
-- extra code for reg/fifo/mem: FIFO 'Timestamp FIFO' data output register 3
rwaddr_reg <= wb_addr_i;
-- ACK signal generation. Just pass the LSB of ACK counter.
wb_ack_o <= ack_sreg(0);
end syn;
